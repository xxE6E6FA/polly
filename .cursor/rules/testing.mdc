---
description: Bun test patterns for React + Convex
globs: ["**/*.test.ts", "**/*.test.tsx"]
---

# Testing Guidelines (Bun)

## Bun Test Architecture

**How Bun Runs Tests:**
- All test files execute in a single process for speed
- Test files run in parallel by default
- Module mocks (`mock.module()`) are process-global and shared
- Tests configure mock behavior via global registries

## Test Isolation & Flakiness Prevention

**ALWAYS** follow these patterns when writing tests to prevent flaky behavior:

### Understanding Bun's Mock System

**CRITICAL CONSTRAINTS**:

- **`mock.module()` is process-global** - All test files run in the same process and share module mocks
- **`mock.restore()` does NOT clear `mock.module()` mocks** - Only clears `spyOn()` and `mock()` function mocks
- **Only ONE mock can exist per module** - Calling `mock.module()` multiple times overwrites previous mocks
- **Parallel execution creates races** - Multiple tests modifying the same mock registry causes interference

**Key Insight**: We install mocks ONCE (in preload) with a shared global registry. Tests configure the registry synchronously before rendering. This causes inherent flakiness when tests run in parallel, but individual files are 100% reliable.

### Module Mocking Strategy

**REQUIRED PATTERN**: Use the global mock registry from `test/global-mocks.ts`:
- Mocks are preloaded once globally before all test files
- Tests configure mock behavior via `setConvexMock()` and `setUserDataMock()`
- Global `afterEach` in `test/global-mocks.ts` clears registries automatically
- Each test must set up its mocks synchronously before rendering

**Use the global mock registry:**
```typescript
// Import global mock helpers
import { setConvexMock, setUserDataMock } from "../../test/global-mocks";

// Import module under test AFTER (mocks are preloaded globally)
const { MyComponent } = await import("./my-component");

// Configure mocks in beforeEach or at the start of each test
beforeEach(() => {
  setConvexMock({
    useQuery: () => myTestData,
    useMutation: () => async () => {},
  });

  setUserDataMock({
    user: { _id: "test-user", isAnonymous: false },
  });
});

// Global afterEach in test/global-mocks.ts clears registries automatically
```

**Why this works:**
- ONE global mock is set up in `test/global-mocks.ts` (preloaded before all tests)
- Tests configure the shared registry synchronously before rendering
- Simple, predictable, and fast

**For mocking non-Convex modules or one-off behaviors, use `spyOn()`:**
```typescript
import * as MyModule from "./my-module";

beforeEach(() => {
  spyOn(MyModule, "myFunction").mockReturnValue(testValue);
  // Global afterEach will restore this automatically
});
```

**NEVER use `mock.module()` in test files** - it's global and causes conflicts. Use the global registries instead.

### Store Isolation (Required for Zustand stores)
For tests using stores like `chat-input-store`, isolate each test with fresh instances:

```typescript
const originalStore = getChatInputStore();

beforeEach(() => {
  setChatInputStoreApi(createChatInputStore()); // Fresh isolated store
  localStorage.clear();
  // ... other setup
});

afterAll(() => {
  setChatInputStoreApi(originalStore); // Restore global store
});
```

**CRITICAL: Store method binding pattern**

When implementing store hooks with `Object.assign`, methods must use **dynamic access** to support test isolation:

```typescript
// ✅ CORRECT - Dynamic access allows setChatInputStoreApi() to work in tests
export const useChatInputStore = Object.assign(useChatInputStoreBase, {
  getState: () => chatInputStoreApi.getState(),
  setState: (...args: Parameters<ChatInputStoreApi["setState"]>) =>
    chatInputStoreApi.setState(...args),
  subscribe: (...args: Parameters<ChatInputStoreApi["subscribe"]>) =>
    chatInputStoreApi.subscribe(...args),
});

// ❌ WRONG - Static binding prevents test isolation
export const useChatInputStore = Object.assign(useChatInputStoreBase, {
  getState: () => chatInputStoreApi.getState(),
  setState: chatInputStoreApi.setState, // Bound at module init!
  subscribe: chatInputStoreApi.subscribe.bind(chatInputStoreApi), // Bound at module init!
});
```

Static binding causes test failures because methods remain bound to the original store instance even after `setChatInputStoreApi()` creates a new one.

### Test Debugging
When tests fail flakily:
1. Note the failing seed from `--seed XXXX`
2. Reproduce with: `bun test --seed XXXX`
3. Use isolated test runs to identify interference

### React Provider Tests & Async Updates

- Prefer exercising real providers instead of mocking them with `mock.module()`. Module-level provider mocks persist across files; they caused seeded failures (see `PrivateModeProvider` under `--seed=1198959309`).
- Render components inside the actual provider and use a tiny initializer component with `useLayoutEffect` to push desired state:
  ```tsx
  function PrivateModeInitializer({ initial, children }: Props) {
    const { setPrivateMode } = usePrivateMode();
    useLayoutEffect(() => setPrivateMode(initial), [initial, setPrivateMode]);
    return <>{children}</>;
  }
  render(
    <PrivateModeProvider>
      <PrivateModeInitializer initial={true}>
        <GenerationModeToggle ... />
      </PrivateModeInitializer>
    </PrivateModeProvider>
  );
  ```
- When DOM assertions depend on state updates triggered by `fireEvent`, wrap them with `await waitFor(...)` (or `await act`) so React finishes processing before the expectation runs.

## Structure
- Location: colocate tests next to implementation files (`*.test.ts(x)`).
- Naming: describe realistic scenarios and expected outcomes.
- Independence: every test must pass in isolation. The suite runs randomized.

## Runner & Environment
- Runner: `bun test` (see `bunfig.toml`).
- DOM: happy‑dom via `test/setup-bun.ts` (optional; only if installed).
- RTL matchers: `@testing-library/jest-dom` loaded from `test/setup-bun.ts` when present.

## React DOM Tests
```ts
import { render, screen } from "@testing-library/react";
import { MyComponent } from "./my-component";

test("shows user name", () => {
  render(<MyComponent name="Ada" />);
  expect(screen.getByText(/ada/i)).toBeInTheDocument();
});
```

## Hook Tests
```ts
import { renderHook, act } from "@testing-library/react";
import { useThing } from "./use-thing";

test("initializes and updates", async () => {
  const { result } = renderHook(() => useThing());
  // Ensure effects/memos complete before invoking methods
  await act(() => globalThis.flushMicrotasks());
  await act(() => result.current.doWork());
  expect(result.current.state.ready).toBe(true);
});
```

## Convex in Frontend Code

**Use the global mock registry pattern:**

```ts
import { setConvexMock } from "../../test/global-mocks";

// Import AFTER global mock is set up
const { MyComponent } = await import("./my-component");

beforeEach(() => {
  // Configure the global Convex mock for this test suite
  // This gets cleared automatically by global afterEach
  setConvexMock({
    useQuery: () => myTestData,
    useMutation: () => async () => {},
  });
});

test("handles empty data", () => {
  // Change the mock behavior for this specific test
  setConvexMock({
    useQuery: () => undefined,
  });
  // test code...
});
```

For query-specific behavior, use a function that checks the query key:
```ts
const functionNameSymbol = Symbol.for("functionName");

beforeEach(() => {
  setConvexMock({
    useQuery: (query, args) => {
      const queryKey = query?.[functionNameSymbol];
      if (queryKey === "messages:list") return serverMessages;
      if (queryKey === "users:getCurrent") return currentUser;
      return undefined;
    },
  });
});
```



## Router Mocks
For React Router, you can either:

**Option 1: Mock at module level** (if stable across all tests in the file):
```ts
const actualRouterDom = await import("react-router-dom");
const navigateStub = createStub((path: string) => {});

mock.module("react-router-dom", () => ({
  ...actualRouterDom,
  useNavigate: () => navigateStub,
}));

beforeEach(() => {
  navigateStub.calls.length = 0; // Clear call history
});
```

**Option 2: Use TestProviders** which wraps components in a MemoryRouter for proper context.

## Convex Function Tests (Backend)

### CRITICAL: Handler Function Pattern

**NEVER call `.handler` on Convex query/mutation/action objects in tests** - this doesn't work because Convex wrappers don't expose `.handler` in test environments.

**REQUIRED PATTERN**: Extract handler functions and test them directly:

```typescript
// ✅ GOOD - Extract handler function
export async function getUserSettingsHandler(ctx: QueryCtx) {
  const userId = await getAuthUserId(ctx);
  if (!userId) {
    return null;
  }
  // ... business logic
}

export const getUserSettings = query({
  args: {},
  handler: getUserSettingsHandler,
});

// ✅ GOOD - Test the handler function directly
import { getUserSettingsHandler } from "./userSettings";
import { makeConvexCtx } from "../test/convex-ctx";

test("returns user settings", async () => {
  const ctx = makeConvexCtx({
    auth: {
      getUserIdentity: mock(() => Promise.resolve({ subject: userId })),
    },
    db: {
      query: mock(() => mockQuery),
    },
  });

  const result = await getUserSettingsHandler(ctx as QueryCtx);
  expect(result).toEqual(expectedSettings);
});

// ❌ BAD - Don't try to call .handler on the wrapper
const result = await getUserSettings.handler(ctx as QueryCtx, {}); // TypeError!
```

### Handler Function Extraction Rules

**For ALL Convex functions (queries, mutations, actions, internal functions):**

1. **Extract the handler logic** into a separate exported function:
   ```typescript
   export async function myQueryHandler(ctx: QueryCtx, args: MyArgs) {
     // Business logic here
   }

   export const myQuery = query({
     args: { ... },
     handler: myQueryHandler,
   });
   ```

2. **Name the handler function** by appending `Handler` to the wrapper name:
   - `getUserSettings` → `getUserSettingsHandler`
   - `updateUserSettings` → `updateUserSettingsHandler`
   - `generateTitle` → `generateTitleHandler`
   - `batchUpdateTitles` → `batchUpdateTitlesHandler`

3. **Export the handler function** so tests can import it directly

4. **Test the handler function**, not the wrapper:
   ```typescript
   import { myQueryHandler } from "./my-module";

   test("does something", async () => {
     const ctx = makeConvexCtx({ ... });
     const result = await myQueryHandler(ctx as QueryCtx, { ... });
     expect(result).toEqual(expected);
   });
   ```

### Benefits of This Pattern

- **Testable**: Handler functions can be tested directly without Convex framework overhead
- **Reusable**: Handler functions can be reused by other Convex functions
- **Maintainable**: Separates business logic from framework concerns
- **Type-safe**: Full TypeScript support in tests

### Alternative: Convex Test Utilities

For integration tests that need the full Convex runtime, use `convex-test` utilities:

```typescript
import { createConvexTestInstance } from "../test/convex-test-utils";

test("integration test", async () => {
  const t = await createConvexTestInstance();
  if (!t) return; // Skip if not available

  const { api } = await import("@convex/_generated/api");
  const result = await t.query(api.users.getById, { id });
  expect(result).toBeTruthy();
});
```

**Prefer handler function pattern** for unit tests (faster, more isolated). Use `convex-test` only for integration tests that need the full Convex runtime.

## Mocking Patterns
```ts
import { mock } from "bun:test";

// Basic module mock
mock.module("@/lib/api", () => ({ fetchUser: async () => ({ id: "1" }) }));

// Component/providers we don’t want active in tests
mock.module("@/providers/convex-provider", () => ({
  ConvexProvider: ({ children }: { children: React.ReactNode }) => <>{children}</>,
  getConvexClient: () => ({})
}));
```

## Best Practices
- Avoid real network, time, or filesystem; mock at module boundaries.
- Reset any global stores/singletons between tests.
- Prefer rendering via RTL and asserting on user‑visible output.
- Keep tests fast and focused; one behavior per test.

## TypeScript Configuration

**Test files are excluded from strict type checking:**

- **Main `tsconfig.json`** excludes all test files (`**/*.test.*`, `**/*.spec.*`)
- **Bun runtime** reads `tsconfig.json` and won't type-check test files when running `bun test`
- **Type checking** uses `bun run typecheck` for the main codebase

This setup allows:
- Type assertions (`as QueryCtx`, `as Id<"conversations">`) without strict type errors
- Mock objects that don't perfectly match real types
- Faster test execution without TypeScript type checking overhead

**Biome linting** is also relaxed for test files:
- `noExplicitAny`: off (allows `any` types)
- `noNonNullAssertion`: off (allows `!` assertions)
- `noUnusedVariables`: warn (not error)
- Naming conventions: off

## Running
- All tests: `bun run test`
- Watch: `bun run test:watch`
- Randomized (seeded): `bun test --randomize --seed 1234`
- Single file: `bun test path/to/file.test.tsx`
