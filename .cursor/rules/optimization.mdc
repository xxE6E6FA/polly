---
description: Performance optimization guidelines and best practices
---

# Performance & Optimization Guidelines

## React Compiler & Memoization Best Practices

### React Compiler Status
- **Enabled**: React Compiler is active and compiles 353/353 components
- **Automatic Optimization**: Let React Compiler handle most optimization
- **Trust the Compiler**: Default to no manual memoization for new code

### Manual Memoization Guidelines

#### âœ… Keep Memoization For
- **useEvent implementations** - Stable event handler pattern
- **Public hook APIs** - Consumer stability contracts
- **Virtualized components** - Performance-critical rendering (custom memo comparators)
- **Provider contexts** - App-wide re-render prevention
- **Expensive computations** - Profiler-verified optimizations (>10ms)
- **Set/Map creation** - O(1) lookup optimizations for large datasets
- **Functions used in other hook dependencies** - Prevents infinite re-renders

#### âŒ Avoid Memoization For
- Simple boolean logic (`isEnabled = status === "active"`)
- Simple string operations (`displayName = user?.name || "Anonymous"`)
- Simple array operations (`items.filter(item => item.visible)`)
- Zero-dependency callbacks (`const handleClick = () => setOpen(true)`)
- Trivial object creation (`{ id, name }`)
- Simple className concatenation

#### ðŸ” Before Adding Memoization
1. **Profile first** - Use React DevTools Profiler to identify actual performance issues
2. **Document reasoning** - Explain why memoization is needed with performance data
3. **Check dependencies** - Ensure the memoized value isn't used in other hook dependencies

### Examples

#### âœ… Good - Let React Compiler Handle It
```tsx
function UserProfile({ user, onEdit }: { user: User; onEdit: (id: string) => void }) {
  // âœ… Simple computations - no memoization needed
  const displayName = user?.name || "Anonymous";
  const isEnabled = user.status === "active" && user.hasPermission;

  // âœ… Simple event handler - no memoization needed
  const handleEdit = () => {
    onEdit(user.id);
  };

  return (
    <div className={cn("user-card", isEnabled && "user-card--enabled")}>
      <h3>{displayName}</h3>
      <button onClick={handleEdit}>Edit</button>
    </div>
  );
}
```

#### âœ… Good - Legitimate Memoization
```tsx
function VirtualizedModelList({ models }: { models: Model[] }) {
  // âœ… Expensive computation for virtualization
  const rows = useMemo(() => {
    const result = [];
    for (let i = 0; i < models.length; i += columnsPerRow) {
      result.push(models.slice(i, i + columnsPerRow));
    }
    return result;
  }, [models, columnsPerRow]);

  // âœ… Set creation for O(1) lookups in large list
  const enabledModelsLookup = useMemo(
    () => new Set(enabledModels.map(m => m.modelId)),
    [enabledModels]
  );

  return <VirtualizedList rows={rows} lookup={enabledModelsLookup} />;
}
```

#### âŒ Bad - Over-Memoization
```tsx
function UserCard({ user }: { user: User }) {
  // âŒ Unnecessary memoization for simple operations
  const displayName = useMemo(() => user?.name || "Anonymous", [user?.name]);

  const isActive = useMemo(() => user.status === "active", [user.status]);

  const handleClick = useCallback(() => {
    console.log("Clicked");
  }, []);

  return <div onClick={handleClick}>{displayName}</div>;
}
```

## React Performance

### Component Optimization
- **Trust React Compiler**: Let it handle most optimization automatically
- **Component Splitting**: Break down large components (>200 lines) into smaller, focused ones
- **Key Props**: Use stable, unique keys for list items (never array indices)
- **Avoid Functions in JSX**: Don't define functions inside JSX that cause re-renders

### State Management
- **Local State First**: Use `useState` for component-local state
- **Context Optimization**: Split contexts to avoid unnecessary re-renders
- **State Lifting**: Lift state up only when needed for sharing
- **Avoid Prop Drilling**: Use context or state management for deep prop passing

### Custom Hooks
- **Single Responsibility**: One hook per concern
- **Reusability**: Only create custom hooks when logic is reused in multiple places
- **Public API Stability**: Memoize callbacks returned from custom hooks to maintain stable references
- **Dependencies**: Properly declare all dependencies in useEffect
- **useEvent Pattern**: Use `useEvent` for stable event handlers in hook APIs

## Bundle Optimization

### Code Splitting
- **Route-based**: Use React.lazy for route components
- **Component-based**: Dynamic imports for large components
- **Vendor Splitting**: Separate vendor chunks for better caching

### Import Optimization
- **Tree Shaking**: Use named imports instead of default imports where possible
- **Dynamic Imports**: Load heavy dependencies on demand
- **Bundle Analysis**: Monitor bundle size with `pnpm build:analyze`

## Data Loading

### Pagination
- **Never Load All**: Don't fetch large datasets (1000+ items) at once
- **Implement Pagination**: Use Convex pagination patterns
- **Virtual Scrolling**: For large lists, use virtualization
- **Infinite Scroll**: Implement infinite loading for better UX

### Caching
- **Convex Caching**: Leverage Convex's built-in caching
- **React Query**: Use for complex data fetching patterns
- **Local Storage**: Cache user preferences and settings
- **Service Worker**: Cache static assets for offline support

## Rendering Optimization

### List Rendering
- **Virtualization**: Use virtual scrolling for large lists
- **Window Scrolling**: Implement window-based rendering
- **Key Optimization**: Use stable keys for list items

### Image Optimization
- **Lazy Loading**: Implement lazy loading for images
- **Responsive Images**: Use appropriate image sizes
- **Format Optimization**: Use modern formats (WebP, AVIF) when supported

## Memory Management

### Event Listeners
- **Cleanup**: Always remove event listeners in useEffect cleanup
- **Passive Listeners**: Use passive listeners for scroll/touch events
- **Debouncing**: Debounce expensive operations

### Object References
- **Stable References**: Use stable object references to prevent re-renders
- **Memoization**: Cache expensive calculations
- **Garbage Collection**: Avoid memory leaks with proper cleanup

## Network Optimization

### API Calls
- **Batching**: Batch multiple API calls when possible
- **Debouncing**: Debounce user input for search/autocomplete
- **Retry Logic**: Implement exponential backoff for failed requests
- **Offline Support**: Handle offline scenarios gracefully

### Streaming
- **Progressive Loading**: Use streaming for large responses
- **Chunk Processing**: Process data in chunks to avoid blocking
- **Error Recovery**: Handle streaming errors gracefully

## Performance Monitoring

### Metrics to Track
- **Core Web Vitals**: LCP, FID, CLS
- **Bundle Size**: Monitor JavaScript bundle size
- **Memory Usage**: Track memory consumption
- **Network Performance**: Monitor API response times

### Tools
- **React DevTools**: Use Profiler for component performance
- **Chrome DevTools**: Monitor performance and memory
- **Bundle Analyzer**: Analyze bundle composition
- **Lighthouse**: Regular performance audits

## Anti-Patterns to Avoid

### Premature Optimization
- **Don't Optimize Early**: Only optimize when there's a clear performance issue
- **Measure First**: Profile before optimizing
- **Simple Solutions**: Prefer simple solutions over complex optimizations

### Common Mistakes
- **Unnecessary Re-renders**: Avoid functions in JSX that cause re-renders
- **Memory Leaks**: Clean up subscriptions and event listeners
- **Blocking Operations**: Don't block the main thread with heavy computations
- **Over-fetching**: Don't fetch more data than needed

## Examples

### Good Performance Patterns
```tsx
// âœ… Legitimate memoization for virtualization
const UserList = ({ users }: { users: User[] }) => {
  // Only memoize expensive chunking for virtual scrolling
  const chunks = useMemo(() => {
    const result = [];
    for (let i = 0; i < users.length; i += CHUNK_SIZE) {
      result.push(users.slice(i, i + CHUNK_SIZE));
    }
    return result;
  }, [users]);

  return (
    <VirtualizedList
      chunks={chunks}
      renderItem={({ item }) => <UserCard user={item} />}
    />
  );
};

// âœ… Proper cleanup
const useWebSocket = (url: string) => {
  useEffect(() => {
    const ws = new WebSocket(url);

    return () => {
      ws.close(); // Cleanup
    };
  }, [url]);
};

// âœ… Debounced search
const useSearch = (query: string) => {
  const [results, setResults] = useState([]);

  useEffect(() => {
    const timeoutId = setTimeout(() => {
      if (query) {
        searchUsers(query).then(setResults);
      }
    }, 300);

    return () => clearTimeout(timeoutId);
  }, [query]);

  return results;
};
```

### Performance Anti-Patterns
```tsx
// âŒ Unnecessary memoization (React Compiler handles this)
const BadComponent = ({ items }) => {
  const processedItems = useMemo(() => {
    return items.map(item => item.value * 2); // Simple operation
  }, [items]);

  const handleClick = useCallback(() => {
    console.log('clicked'); // Zero dependencies
  }, []);

  return <div onClick={handleClick}>{processedItems.join(', ')}</div>;
};

// âœ… Better - let React Compiler optimize
const GoodComponent = ({ items }) => {
  const processedItems = items.map(item => item.value * 2);

  const handleClick = () => {
    console.log('clicked');
  };

  return <div onClick={handleClick}>{processedItems.join(', ')}</div>;
};

// âŒ Missing cleanup
const BadWebSocket = (url: string) => {
  useEffect(() => {
    const ws = new WebSocket(url);
    // Missing cleanup - memory leak!
  }, [url]);
};

// âŒ Unnecessary re-renders
const BadList = ({ users }) => {
  return (
    <div>
      {users.map((user, index) => (
        <UserCard key={index} user={user} /> // Using index as key
      ))}
    </div>
  );
};
```
