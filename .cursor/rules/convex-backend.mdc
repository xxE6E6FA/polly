---
description: Convex backend patterns and conventions
globs: ["convex/**/*.ts"]
---

# Convex Backend Patterns

## Imports
- **Static Imports Only**: Always use static imports (`import`), never dynamic imports (`await import()`)
- **TypeScript Compatibility**: Dynamic imports are not supported in Convex's TypeScript configuration
- **Module Resolution**: Use explicit `.js` extensions for relative imports in Convex files

```typescript
// ✅ Good - static import
import { getUserFriendlyErrorMessage } from "./ai/error_handlers.js";
import { log } from "../lib/logger.js";

// ❌ Bad - dynamic import (not supported)
const { getUserFriendlyErrorMessage } = await import("./ai/error_handlers");
```

## Logging (CRITICAL)
- **MUST use `log.*`**: Import from `convex/lib/logger`
- **Console is BLOCKED**: `console.log`, `console.error` are lint-blocked in convex files (except in `convex/lib/logger.ts`)
- **Proper Logging**: Use structured logging with context
- **Logger Implementation**: The logger itself uses console methods internally but is the only allowed usage

```typescript
import { log } from "@convex/lib/logger";

// ✅ Good logging
log.info("User created", { userId, email });
log.error("Database error", { error: error.message, query });
log.warn("Rate limit exceeded", { userId, endpoint });

// ❌ Bad - console is blocked
console.log("Debug info"); // Lint error!
```

## Function Naming
- **camelCase**: All function names must be camelCase (not PascalCase)
- **Descriptive**: Use clear, descriptive function names
- **Consistent**: Follow established patterns in the codebase

```typescript
// ✅ Good function names
export const getUserById = query({
  // ...
});

export const createUser = mutation({
  // ...
});

// ❌ Bad - PascalCase
export const GetUserById = query({
  // ...
});
```

## Handler Function Extraction (REQUIRED for Testability)

**ALWAYS extract handler functions** from Convex wrappers to enable testing:

```typescript
// ✅ GOOD - Extract handler function
export async function getUserByIdHandler(ctx: QueryCtx, id: Id<"users">) {
  return await ctx.db.get(id);
}

export const getUserById = query({
  args: { id: v.id("users") },
  handler: getUserByIdHandler,
});

// ❌ BAD - Inline handler (not testable)
export const getUserById = query({
  args: { id: v.id("users") },
  handler: async (ctx, args) => {
    return await ctx.db.get(args.id);
  },
});
```

**Naming Convention**: Append `Handler` to the wrapper name:
- `getUserSettings` → `getUserSettingsHandler`
- `updateUserSettings` → `updateUserSettingsHandler`
- `generateTitle` → `generateTitleHandler`

**Benefits**:
- Enables unit testing without Convex runtime
- Makes business logic reusable
- Separates framework concerns from business logic
- See `.cursor/rules/testing.mdc` for testing patterns

## Error Handling
- **Structured Errors**: Include context in error logs
- **User-Friendly Messages**: Return meaningful error messages to frontend
- **Graceful Degradation**: Handle errors without crashing the system

```typescript
export const getUserProfile = query({
  args: { userId: Id<"users"> },
  handler: async (ctx, { userId }) => {
    try {
      const user = await ctx.db.get(userId);
      if (!user) {
        log.warn("User not found", { userId });
        return null;
      }
      return user;
    } catch (error) {
      log.error("Failed to get user profile", { 
        userId, 
        error: error instanceof Error ? error.message : "Unknown error" 
      });
      throw new Error("Failed to retrieve user profile");
    }
  },
});
```

## Data Access Patterns
- **Use ctx.db**: Always use the database context
- **Proper Types**: Use Convex ID types (`Id<"tableName">`)
- **Validation**: Validate input arguments
- **Pagination**: Implement pagination for large datasets

```typescript
export const getMessages = query({
  args: { 
    conversationId: Id<"conversations">,
    paginationOpts: paginationOptsValidator
  },
  handler: async (ctx, { conversationId, paginationOpts }) => {
    return await ctx.db
      .query("messages")
      .withIndex("by_conversation", (q) => q.eq("conversationId", conversationId))
      .paginate(paginationOpts);
  },
});
```

## HTTP Actions
- **Streaming**: Use proper streaming patterns for real-time responses
- **Error Responses**: Return proper HTTP status codes
- **Input Validation**: Validate all incoming data

```typescript
export const streamChat = action({
  args: { message: string, conversationId: Id<"conversations"> },
  handler: async (ctx, { message, conversationId }) => {
    try {
      // Validate input
      if (!message.trim()) {
        throw new Error("Message cannot be empty");
      }

      // Process streaming response
      const stream = await processChatMessage(ctx, { message, conversationId });
      return stream;
    } catch (error) {
      log.error("Chat streaming failed", { 
        conversationId, 
        error: error instanceof Error ? error.message : "Unknown error" 
      });
      throw new Error("Failed to process chat message");
    }
  },
});
```

## File Organization
- **Logical Grouping**: Group related functions together
- **Clear Exports**: Export only what's needed
- **Type Definitions**: Define types in separate files when shared

## Performance Considerations
- **Efficient Queries**: Use proper indexes and query patterns
- **Caching**: Implement caching where appropriate
- **Batch Operations**: Use batch operations for multiple database writes

## Security
- **Authentication**: Always check user authentication
- **Authorization**: Verify user permissions
- **Input Sanitization**: Sanitize all user inputs
- **Rate Limiting**: Implement rate limiting for public endpoints

```typescript
export const updateUserSettings = mutation({
  args: { settings: userSettingsValidator },
  handler: async (ctx, { settings }) => {
    // Check authentication
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new Error("Not authenticated");
    }

    // Get user
    const user = await ctx.db
      .query("users")
      .withIndex("by_tokenIdentifier", (q) => 
        q.eq("tokenIdentifier", identity.tokenIdentifier)
      )
      .unique();

    if (!user) {
      throw new Error("User not found");
    }

    // Update settings
    await ctx.db.patch(user._id, { settings });
    log.info("User settings updated", { userId: user._id });
  },
});
```