---
description: Core code style and formatting standards
alwaysApply: true
---

# Code Style & Formatting

## Biome Configuration
- **Indentation**: 2 spaces (not tabs)
- **Line Width**: 80 characters maximum
- **Quotes**: Double quotes for strings
- **Semicolons**: Always required
- **Trailing Commas**: ES5 style

## Naming Conventions
- **Functions/Variables**: camelCase (`getUserData`, `isLoading`)
- **Components/Types**: PascalCase (`UserProfile`, `ApiResponse`)
- **Constants**: CONSTANT_CASE (`API_BASE_URL`, `MAX_RETRIES`)
- **Files**: kebab-case for components (`user-profile.tsx`), camelCase for utilities (`userUtils.ts`)

## TypeScript Standards
- **Strict Mode**: Always enabled
- **No `any` Types**: Use proper typing or `unknown` with type guards
- **Type Imports**: Use `import type` for type-only imports
- **Optional Chaining**: Prefer `?.` over manual null checks
- **Exhaustive Dependencies**: All useEffect dependencies must be declared

## Import Organization
- **Aliases**: Use `@/` for src imports, `@convex/` for convex, `@shared/` for shared
- **Order**: External packages → Internal aliases → Relative imports
- **Auto-organize**: Run `pnpm check:write` to auto-organize imports

## Code Quality

### Biome Rules (Enforced)

**Formatting:**
- Indentation: 2 spaces (never tabs)
- Line width: 80 characters max
- Quotes: Double quotes for strings and JSX
- Semicolons: Always required
- Trailing commas: ES5 style
- Arrow parentheses: As needed (omit for single param)
- Bracket spacing: Always `{ foo }` not `{foo}`

**React/JSX:**
- Self-closing elements: Always use `<Button />` for no children
- Fragment syntax: `<>...</>` not `<Fragment>...</Fragment>`
- No array index keys: Never use `map((item, i) => <div key={i}>)`
- No children prop: Use composition `<Button>Click</Button>` not `<Button children="Click" />`
- Exhaustive dependencies: All useEffect/useMemo/useCallback deps must be declared

**TypeScript:**
- No `any` type: Use proper types or `unknown` with type guards
- Type imports: `import type { Foo }` for types (auto-organized)
- Export types: `export type { Bar }` for type exports
- Optional chaining: Prefer `a?.b?.c` over `a && a.b && a.b.c`
- Const assertions: Use `as const` for literal types
- No non-null assertion: Avoid `!` operator (warning only)
- Array literals: Use `[]` not `new Array()` or `Array()`

**Control Flow:**
- No nested ternaries: Use if/else or helper functions
- Use block statements: Always `{}` for if/else/while bodies
- No useless else: Remove else after return/throw
- No double equals: Always use `===` not `==`

**Best Practices:**
- No console: Use `log.*` from `convex/lib/logger` in backend
- No unused variables: All declared vars must be used
- No empty blocks: Empty `{}` forbidden
- No debugger: Remove all debugger statements
- No parameter reassign: Don't reassign function params
- Use template literals: `` `${x}` `` over `"" + x`
- Error handling: Proper try/catch with meaningful messages
- Comments: Only for complex logic, not obvious code
- DRY principle: Extract reusable functions
- No IIFEs in JSX: Extract to helper functions or components

## Examples

```typescript
// ✅ Good
import type { User } from "@/types";
import { log } from "@convex/lib/logger";
import { Button } from "@/components/ui/button";

const getUserData = async (userId: string): Promise<User | null> => {
  try {
    const response = await fetch(`/api/users/${userId}`);
    return await response.json();
  } catch (error) {
    log.error("Failed to fetch user data", { userId, error });
    return null;
  }
};

// ❌ Bad
import { User } from "@/types"; // Should be type import
console.log("Debug info"); // Use log instead
const getUserData = async (userId: string) => { // Missing return type
  // ...
};

// ✅ Good - Avoiding nested ternaries
const getButtonTitle = () => {
  if (isStreaming) {
    return "Stop";
  }
  if (hasInputText) {
    return "Send message";
  }
  return "Start voice input";
};

// ❌ Bad - Nested ternaries
const getButtonTitle = () => {
  return isStreaming ? "Stop" : hasInputText ? "Send message" : "Start voice input";
};

// ❌ Bad - IIFE in JSX
<button>
  {(() => {
    if (condition) return <Icon1 />;
    return <Icon2 />;
  })()}
</button>

// ✅ Good - Extract to helper function
function getIcon(condition: boolean) {
  if (condition) return <Icon1 />;
  return <Icon2 />;
}

<button>
  {getIcon(condition)}
</button>
```