---
description: React Compiler optimization guidelines and memoization best practices
---

# React Compiler & Memoization Best Practices

## React Compiler Status

- **Enabled**: React Compiler is active via `babel-plugin-react-compiler` in `vite.config.ts`
- **Compilation**: 353/353 components successfully compiled
- **Automatic Optimization**: React Compiler handles most performance optimizations automatically

## Core Philosophy

### Default Approach
- **Trust the Compiler**: Let React Compiler handle optimization automatically
- **Profile First**: Use React DevTools Profiler before adding manual optimizations
- **Document Reasoning**: Always explain why manual memoization is needed with performance data

### When NOT to Memoize

React Compiler automatically optimizes these patterns, so avoid manual memoization:

```tsx
// ‚ùå Don't memoize simple computations
const displayName = useMemo(() => user?.name || "Anonymous", [user?.name]);

// ‚ùå Don't memoize simple boolean logic
const isActive = useMemo(() => status === "active" && hasPermission, [status, hasPermission]);

// ‚ùå Don't memoize simple array operations
const visibleItems = useMemo(() => items.filter(item => item.visible), [items]);

// ‚ùå Don't memoize zero-dependency callbacks
const handleClick = useCallback(() => setOpen(true), []);

// ‚ùå Don't memoize trivial object creation
const userInfo = useMemo(() => ({ id: user.id, name: user.name }), [user.id, user.name]);

// ‚úÖ Instead, let React Compiler optimize automatically
function UserCard({ user, status, items }) {
  const displayName = user?.name || "Anonymous";
  const isActive = status === "active" && hasPermission;
  const visibleItems = items.filter(item => item.visible);

  const handleClick = () => setOpen(true);
  const userInfo = { id: user.id, name: user.name };

  return <div onClick={handleClick}>{displayName}</div>;
}
```

## When TO Keep Memoization

### 1. useEvent Implementation ‚úÖ

```tsx
// ‚úÖ Keep - Implements useEvent RFC pattern
export function useEvent<Args extends unknown[], Return>(
  handler: (...args: Args) => Return
): (...args: Args) => Return {
  const handlerRef = useRef<((...args: Args) => Return) | null>(null);

  useLayoutEffect(() => {
    handlerRef.current = handler;
  }, [handler]);

  return useCallback((...args: Args) => {
    const fn = handlerRef.current;
    if (!fn) throw new Error("useEvent handler called before ref was set");
    return fn(...args);
  }, []);
}
```

### 2. Public Hook APIs ‚úÖ

```tsx
// ‚úÖ Keep - Public hook API requires stable references
export function useChatSubmission() {
  const submitMessage = useCallback(async (content: string) => {
    // Implementation
  }, [/* dependencies */]);

  const uploadFile = useCallback(async (file: File) => {
    // Implementation
  }, [/* dependencies */]);

  // These are part of the public API contract
  return { submitMessage, uploadFile };
}
```

### 3. Expensive Computations ‚úÖ

```tsx
// ‚úÖ Keep - Expensive chunking for virtualization (profiler-verified >10ms)
function VirtualizedModelList({ models }) {
  const rows = useMemo(() => {
    // PERF: Prevents re-chunking 200+ models on every render
    // Benchmark: 15ms -> 0.5ms per render (React DevTools Profiler)
    const result = [];
    for (let i = 0; i < models.length; i += columnsPerRow) {
      result.push(models.slice(i, i + columnsPerRow));
    }
    return result;
  }, [models, columnsPerRow]);

  return <VirtualizedList rows={rows} />;
}
```

### 4. Set/Map Creation for Lookups ‚úÖ

```tsx
// ‚úÖ Keep - O(1) lookup optimization for large datasets
function ModelPicker({ models, enabledModels }) {
  const enabledLookup = useMemo(
    () => new Set(enabledModels.map(m => m.modelId)),
    [enabledModels]
  );

  return models.map(model => (
    <ModelCard
      key={model.id}
      model={model}
      isEnabled={enabledLookup.has(model.id)} // O(1) instead of O(n)
    />
  ));
}
```

### 5. Provider Context Values ‚úÖ

```tsx
// ‚úÖ Keep - Prevents app-wide re-renders
export function UserDataProvider({ children }) {
  const identityValue = useMemo(() => ({
    user: combinedValue.user,
    isAuthenticated: combinedValue.isAuthenticated,
    isLoading: combinedValue.isLoading,
  }), [combinedValue.user, combinedValue.isAuthenticated, combinedValue.isLoading]);

  return (
    <UserIdentityContext.Provider value={identityValue}>
      {children}
    </UserIdentityContext.Provider>
  );
}
```

### 6. Custom React.memo Comparators ‚úÖ

```tsx
// ‚úÖ Keep - Performance-critical for virtualized components
export const AttachmentStrip = memo(AttachmentStripComponent, (prev, next) => {
  if (prev.variant !== next.variant || prev.className !== next.className) {
    return false;
  }

  const a = prev.attachments || [];
  const b = next.attachments || [];

  if (a.length !== b.length) return false;

  for (let i = 0; i < a.length; i++) {
    if (a[i]?.url !== b[i]?.url || a[i]?.name !== b[i]?.name) {
      return false;
    }
  }

  return true;
});
```

### 7. Functions Used in Hook Dependencies ‚úÖ

```tsx
// ‚úÖ Keep - Used in other hook dependencies
function useCommandPalette() {
  const handleAction = useCallback((actionId: string) => {
    // Implementation
  }, [/* dependencies */]);

  // This depends on the memoized handleAction above
  const actions = useMemo(() => [
    { id: 'new', label: 'New Chat', action: () => handleAction('new') },
    { id: 'settings', label: 'Settings', action: () => handleAction('settings') },
  ], [handleAction]); // ‚Üê Removing handleAction's useCallback breaks this

  return { actions };
}
```

## Migration Guidelines

### For New Code
1. **Default to no memoization** - let React Compiler handle it
2. **Add memoization only when**:
   - Profiler shows actual performance issue (>10ms)
   - Working with virtualized lists (50+ items)
   - Creating public hook APIs
   - Building expensive data structures (Maps, Sets, nested loops)
3. **Always document why**:
   ```tsx
   // PERF: Memoize to prevent re-chunking 200+ models on every render
   // Benchmark: 15ms -> 0.5ms per render (React DevTools Profiler)
   const rows = useMemo(() => { /* ... */ }, [models, columnsPerRow]);
   ```

### For Existing Code
1. **Trust existing legitimate optimizations** - they were preserved during audit
2. **Don't remove memoization that's part of dependency chains**
3. **Profile before changing** - ensure no performance regressions

## Debugging Performance Issues

### React DevTools Profiler Workflow
1. **Record baseline** - Profile component before changes
2. **Make changes** - Remove/add memoization
3. **Compare results** - Look for render count and timing differences
4. **Revert if needed** - If performance degrades, keep the optimization

### Key Metrics to Monitor
- **Render count** - Unnecessary re-renders
- **Render duration** - Time spent rendering
- **Phase duration** - Time in commit vs render phases
- **Memory usage** - Avoid memory leaks from retained references

## Common Anti-Patterns

### Over-Memoization
```tsx
// ‚ùå Don't over-memoize simple operations
function UserCard({ user }) {
  const initials = useMemo(() =>
    user.name.split(' ').map(n => n[0]).join(''),
    [user.name]
  );

  const avatarStyle = useMemo(() => ({
    backgroundColor: user.color,
    color: 'white'
  }), [user.color]);

  const handleClick = useCallback(() => {
    console.log('User clicked');
  }, []);

  return <div style={avatarStyle} onClick={handleClick}>{initials}</div>;
}

// ‚úÖ Better - let React Compiler optimize
function UserCard({ user }) {
  const initials = user.name.split(' ').map(n => n[0]).join('');
  const avatarStyle = { backgroundColor: user.color, color: 'white' };
  const handleClick = () => console.log('User clicked');

  return <div style={avatarStyle} onClick={handleClick}>{initials}</div>;
}
```

### Dependency Chain Breaking
```tsx
// ‚ùå Don't remove memoization that breaks dependency chains
function useSearch(query) {
  // If you remove this useCallback...
  const performSearch = useCallback(async (q) => {
    return await searchAPI(q);
  }, []);

  // ...this will cause infinite re-renders
  useEffect(() => {
    if (query) {
      performSearch(query).then(setResults);
    }
  }, [query, performSearch]); // ‚Üê performSearch dependency needed
}
```

## Best Practices Summary

### ‚úÖ Do
- Trust React Compiler for automatic optimization
- Profile before optimizing
- Document performance reasoning
- Keep memoization for legitimate use cases
- Use stable references for public APIs

### ‚ùå Don't
- Memoize simple computations
- Remove memoization without profiling
- Use memoization as default approach
- Break existing dependency chains
- Over-engineer performance prematurely

### üîç Always Ask
1. Does the profiler show this is actually slow?
2. Is this memoized value used in other hook dependencies?
3. Is this a public API that needs stable references?
4. Would removing this break the application?

React Compiler + selective manual optimization = optimal performance with maintainable code.
