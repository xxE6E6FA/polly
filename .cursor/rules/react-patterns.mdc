---
description: React component patterns and best practices
globs: ["src/components/**/*.tsx", "src/pages/**/*.tsx", "src/hooks/**/*.ts"]
---

# React Patterns & Best Practices

## Component Structure
- **Functional Components**: Always use function components with hooks
- **PascalCase Names**: Component names must be PascalCase
- **Fragment Syntax**: Use `<>` instead of `<React.Fragment>`
- **Self-closing Elements**: `<div />` not `<div></div>`

## Hooks Guidelines
- **Top Level Only**: Hooks must be called at component top level
- **Exhaustive Dependencies**: All useEffect dependencies must be declared
- **Custom Hooks**: Only create when logic is reused in multiple places
- **Single Responsibility**: One hook per concern

## Performance Patterns
- **Avoid Functions in Components**: Don't define functions inside components that cause re-renders
- **No Premature Optimization**: Only optimize when there's a clear performance issue
- **Avoid Prop Drilling**: Use context or state management for deep prop passing
- **Component Splitting**: Break down large components into smaller, focused ones

## State Management
- **Local State First**: Use useState for component-local state
- **Context for Shared State**: Use React context for state shared across components
- **Avoid Monolithic Components**: Keep components focused and single-purpose

## Conditional Rendering
- **Avoid Nested Ternaries**: Use early returns or separate components
- **Clear Conditions**: Make conditional logic explicit and readable
- **Fragment Wrapping**: Use fragments to avoid unnecessary DOM nodes

## Effects Guidelines

### When NOT to Use Effects
- **Don't use Effects to transform data for rendering**: Calculate derived values during render instead
- **Don't use Effects to handle user events**: Use event handlers instead
- **Don't use Effects to update state based on props/state**: Calculate during render or use `useMemo`

### When to Use Effects
- **Synchronizing with external systems**: APIs, DOM, third-party libraries
- **Data fetching**: When you need to fetch data based on props/state changes
- **Subscriptions**: WebSocket connections, event listeners
- **Cleanup**: Always provide cleanup functions for subscriptions

### Effect Anti-Patterns

```tsx
// ‚ùå Bad: Redundant state and unnecessary Effect
function Form() {
  const [firstName, setFirstName] = useState('Taylor');
  const [lastName, setLastName] = useState('Swift');
  
  // üî¥ Avoid: redundant state and unnecessary Effect
  const [fullName, setFullName] = useState('');
  useEffect(() => {
    setFullName(firstName + ' ' + lastName);
  }, [firstName, lastName]);
  
  return <div>{fullName}</div>;
}

// ‚úÖ Good: Calculate during rendering
function Form() {
  const [firstName, setFirstName] = useState('Taylor');
  const [lastName, setLastName] = useState('Swift');
  
  // ‚úÖ Good: calculated during rendering
  const fullName = firstName + ' ' + lastName;
  
  return <div>{fullName}</div>;
}
```

### Caching Expensive Calculations

```tsx
// ‚ùå Bad: Using Effect for expensive calculations
function TodoList({ todos, filter }) {
  const [visibleTodos, setVisibleTodos] = useState([]);
  
  useEffect(() => {
    setVisibleTodos(getFilteredTodos(todos, filter));
  }, [todos, filter]);
  
  return <ul>{visibleTodos.map(todo => <li key={todo.id}>{todo.text}</li>)}</ul>;
}

// ‚úÖ Good: Use useMemo for expensive calculations
function TodoList({ todos, filter }) {
  const visibleTodos = useMemo(() => {
    return getFilteredTodos(todos, filter);
  }, [todos, filter]);
  
  return <ul>{visibleTodos.map(todo => <li key={todo.id}>{todo.text}</li>)}</ul>;
}
```

### Data Fetching with Effects

```tsx
// ‚úÖ Good: Data fetching with proper cleanup
function SearchResults({ query }) {
  const [results, setResults] = useState([]);
  const [page, setPage] = useState(1);
  
  useEffect(() => {
    let ignore = false;
    
    fetchResults(query, page).then(json => {
      if (!ignore) {
        setResults(json);
      }
    });
    
    return () => {
      ignore = true; // Cleanup to avoid race conditions
    };
  }, [query, page]);
  
  return <div>{results.map(result => <div key={result.id}>{result.title}</div>)}</div>;
}
```

### Key Principles
- **Calculate during render**: If something can be calculated from existing props/state, don't put it in state
- **Use useMemo for expensive calculations**: Cache expensive computations with useMemo
- **Handle user events in event handlers**: Don't use Effects for user interactions
- **Always provide cleanup**: For subscriptions, timers, and async operations
- **Avoid race conditions**: Use cleanup functions in data fetching Effects

## ESLint React Hooks Rules

Based on [React's ESLint plugin recommendations](https://react.dev/reference/eslint-plugin-react-hooks#recommended):

### Rules of Hooks (rules-of-hooks)
- **Top Level Only**: Hooks must be called at the top level of components/hooks
- **No Conditional Hooks**: Don't call hooks inside loops, conditions, or nested functions
- **Consistent Order**: Hooks must be called in the same order every time

```tsx
// ‚ùå Bad: Conditional hook usage
function BadComponent({ shouldFetch }) {
  if (shouldFetch) {
    const [data, setData] = useState(null); // Violates rules-of-hooks
  }
  return <div>Content</div>;
}

// ‚úÖ Good: Always call hooks at top level
function GoodComponent({ shouldFetch }) {
  const [data, setData] = useState(null);
  
  useEffect(() => {
    if (shouldFetch) {
      fetchData().then(setData);
    }
  }, [shouldFetch]);
  
  return <div>Content</div>;
}
```

### Exhaustive Dependencies (exhaustive-deps)
- **Complete Dependencies**: Include all values from component scope used inside Effect
- **Stable References**: Use useCallback/useMemo for functions/objects in dependencies
- **No Missing Dependencies**: ESLint will warn about missing dependencies

```tsx
// ‚ùå Bad: Missing dependencies
function BadComponent({ userId }) {
  const [user, setUser] = useState(null);
  
  useEffect(() => {
    fetchUser(userId).then(setUser); // Missing userId dependency
  }, []); // Empty dependency array
  
  return <div>{user?.name}</div>;
}

// ‚úÖ Good: Complete dependencies
function GoodComponent({ userId }) {
  const [user, setUser] = useState(null);
  
  useEffect(() => {
    fetchUser(userId).then(setUser);
  }, [userId]); // Include all dependencies
  
  return <div>{user?.name}</div>;
}
```

### Component Purity (purity)
- **Pure Functions**: Components must be pure - same props = same output
- **No Side Effects in Render**: Don't mutate state, call APIs, or perform side effects during render
- **Stable References**: Use useCallback/useMemo for stable function/object references

```tsx
// ‚ùå Bad: Side effects during render
function BadComponent({ data }) {
  const processedData = processData(data); // Expensive calculation every render
  
  // Side effect during render
  if (data.length > 100) {
    console.log('Large dataset'); // Side effect!
  }
  
  return <div>{processedData}</div>;
}

// ‚úÖ Good: Pure component with memoization
function GoodComponent({ data }) {
  const processedData = useMemo(() => processData(data), [data]);
  
  return <div>{processedData}</div>;
}
```

### Immutability (immutability)
- **Don't Mutate Props**: Props are read-only
- **Don't Mutate State**: Use setState with new values, not mutations
- **Don't Mutate Refs**: Refs should be stable references

```tsx
// ‚ùå Bad: Mutating props/state
function BadComponent({ items }) {
  const [list, setList] = useState(items);
  
  const addItem = (item) => {
    list.push(item); // Mutating state!
    setList(list);
  };
  
  return <div>{list.map(item => <div key={item.id}>{item.name}</div>)}</div>;
}

// ‚úÖ Good: Immutable updates
function GoodComponent({ items }) {
  const [list, setList] = useState(items);
  
  const addItem = (item) => {
    setList(prev => [...prev, item]); // Immutable update
  };
  
  return <div>{list.map(item => <div key={item.id}>{item.name}</div>)}</div>;
}
```

### State Management (set-state-in-effect, set-state-in-render)
- **No State Updates in Render**: Don't call setState during render
- **No Synchronous State Updates in Effects**: Avoid immediate state updates in Effects
- **Use Event Handlers**: Handle state updates in event handlers when possible

```tsx
// ‚ùå Bad: State update during render
function BadComponent({ data }) {
  const [processed, setProcessed] = useState(null);
  
  if (data && !processed) {
    setProcessed(processData(data)); // State update during render!
  }
  
  return <div>{processed}</div>;
}

// ‚úÖ Good: Calculate during render or use Effect properly
function GoodComponent({ data }) {
  const processed = useMemo(() => data ? processData(data) : null, [data]);
  
  return <div>{processed}</div>;
}
```

### Static Components (static-components)
- **Don't Recreate Components**: Avoid defining components inside other components
- **Use Stable References**: Components should be defined outside render or memoized

```tsx
// ‚ùå Bad: Component defined inside render
function BadParent() {
  const [count, setCount] = useState(0);
  
  // Component recreated every render
  function ChildComponent() {
    return <div>Count: {count}</div>;
  }
  
  return <ChildComponent />;
}

// ‚úÖ Good: Component defined outside or memoized
const ChildComponent = memo(({ count }) => {
  return <div>Count: {count}</div>;
});

function GoodParent() {
  const [count, setCount] = useState(0);
  return <ChildComponent count={count} />;
}
```

### Error Boundaries (error-boundaries)
- **Use Error Boundaries**: Catch errors with Error Boundaries, not try/catch
- **Class Components**: Error Boundaries must be class components
- **Fallback UI**: Provide meaningful fallback UI for error states

```tsx
// ‚ùå Bad: try/catch for child component errors
function BadComponent() {
  try {
    return <ChildComponentThatMightError />;
  } catch (error) {
    return <div>Error occurred</div>; // Won't catch child errors
  }
}

// ‚úÖ Good: Use Error Boundary
function GoodComponent() {
  return (
    <ErrorBoundary fallback={<div>Something went wrong</div>}>
      <ChildComponentThatMightError />
    </ErrorBoundary>
  );
}
```

## Examples

```tsx
// ‚úÖ Good component structure (from actual codebase)
import { memo, useCallback, useEffect, useMemo, useRef, useState } from "react";
import { Button } from "@/components/ui/button";

interface UserProfileProps {
  userId: string;
  onUpdate?: (user: User) => void;
}

export const UserProfile = memo(({ userId, onUpdate }: UserProfileProps) => {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    const fetchUser = async () => {
      try {
        const userData = await getUserData(userId);
        setUser(userData);
      } catch (error) {
        log.error("Failed to fetch user", { userId, error });
      } finally {
        setIsLoading(false);
      }
    };

    fetchUser();
  }, [userId]);

  const handleUpdate = useCallback((updatedUser: User) => {
    setUser(updatedUser);
    onUpdate?.(updatedUser);
  }, [onUpdate]);

  // Memoize expensive calculations
  const userDisplayName = useMemo(() => {
    return user ? `${user.firstName} ${user.lastName}` : "Unknown User";
  }, [user]);

  if (isLoading) {
    return <div>Loading...</div>;
  }

  if (!user) {
    return <div>User not found</div>;
  }

  return (
    <>
      <h1>{userDisplayName}</h1>
      <Button onClick={() => handleUpdate(user)}>
        Update Profile
      </Button>
    </>
  );
});

// ‚ùå Bad patterns
export function BadComponent({ userId }) { // Missing types
  const [user, setUser] = useState(null);
  
  // ‚ùå Function defined inside component
  const fetchUser = async () => {
    // ...
  };
  
  // ‚ùå Nested ternary
  return user ? user.name ? <div>{user.name}</div> : <div>No name</div> : <div>Loading</div>;
}
```

## Anti-Patterns to Avoid
- **Functions in JSX**: Don't define functions in render
- **Array Index Keys**: Use stable, unique keys for list items
- **Inline Styles**: Use Tailwind classes instead
- **Large Components**: Break down components over 200 lines
- **Prop Drilling**: Don't pass props through many levels