import { ConvexError } from "convex/values";
import type { Id } from "../../_generated/dataModel";
import type { MutationCtx, QueryCtx } from "../../_generated/server";
import { withRetry } from "../../ai/error_handlers";
import { createUserFileEntriesHandler } from "../file_storage/mutation_handlers";
import type { Infer } from "convex/values";
import type {
  attachmentSchema,
  ttsAudioCacheEntrySchema,
  webCitationSchema,
} from "../schemas";

export async function addAttachmentsHandler(
  ctx: MutationCtx,
  args: {
    messageId: Id<"messages">;
    attachments: Infer<typeof attachmentSchema>[];
  }
) {
  const { messageId, attachments } = args;

  try {
    // Get current message to preserve existing attachments
    const message = await ctx.db.get("messages", messageId);
    if (!message) {
      return;
    }

    // Merge with existing attachments, deduplicating generated images by URL
    const existingAttachments = message.attachments || [];
    if (!attachments.length) {
      await ctx.db.patch("messages", messageId, {
        attachments: existingAttachments,
      });
      return;
    }

    // Track URLs for generated images already present
    const existingGeneratedUrls = new Set(
      existingAttachments
        .filter(
          a => a.type === "image" && a.generatedImage?.isGenerated && !!a.url
        )
        .map(a => a.url)
    );

    // Track which attachments are actually new (for creating userFiles entries)
    const newAttachments: typeof attachments = [];

    const merged: typeof existingAttachments = [...existingAttachments];
    for (const att of attachments) {
      // If this is a generated image and we already have an image with the same URL, skip it
      if (
        att.type === "image" &&
        att.generatedImage?.isGenerated &&
        att.url &&
        existingGeneratedUrls.has(att.url)
      ) {
        continue;
      }
      if (
        att.type === "image" &&
        att.generatedImage?.isGenerated &&
        att.url
      ) {
        existingGeneratedUrls.add(att.url);
      }
      merged.push(att);
      newAttachments.push(att);
    }

    const updatedAttachments = merged;

    await ctx.db.patch("messages", messageId, {
      attachments: updatedAttachments,
    });

    // Create userFiles entries for new attachments (enables file library features)
    // This is especially important for generated images which bypass the normal upload flow
    if (newAttachments.length > 0) {
      const conversation = await ctx.db.get(
        "conversations",
        message.conversationId
      );
      if (conversation) {
        await createUserFileEntriesHandler(ctx, {
          userId: conversation.userId,
          messageId,
          conversationId: message.conversationId,
          attachments: newAttachments,
        });
      }
    }
  } catch (error) {
    console.error("[addAttachments] Error:", error);
    throw new ConvexError(
      `Failed to add attachments to message ${messageId}: ${error instanceof Error ? error.message : String(error)}`
    );
  }
}

export async function clearImageGenerationAttachmentsHandler(
  ctx: MutationCtx,
  args: { messageId: Id<"messages"> }
) {
  const { messageId } = args;

  try {
    const message = await ctx.db.get("messages", messageId);
    if (!message) {
      return;
    }

    // Filter out image attachments that were generated by looking for the generatedImage metadata
    // Keep all non-image attachments and user-uploaded images
    const filteredAttachments = (message.attachments || []).filter(
      attachment => {
        if (attachment.type !== "image") {
          return true; // Keep all non-image attachments
        }

        // Check if this is a generated image by looking for the generatedImage metadata
        const hasGeneratedMetadata =
          attachment.generatedImage?.isGenerated === true;
        const shouldKeep = !hasGeneratedMetadata; // Keep only non-generated images

        return shouldKeep;
      }
    );

    await ctx.db.patch("messages", messageId, {
      attachments: filteredAttachments,
    });
  } catch (error) {
    console.error("[clearImageGenerationAttachments] Error:", error);
    throw new ConvexError(
      `Failed to clear image generation attachments for message ${messageId}: ${error instanceof Error ? error.message : String(error)}`
    );
  }
}

export async function updateImageGenerationHandler(
  ctx: MutationCtx,
  args: {
    messageId: Id<"messages">;
    replicateId?: string;
    status?: string;
    output?: string[];
    error?: string;
    metadata?: {
      duration?: number;
      model?: string;
      prompt?: string;
      params?: {
        aspectRatio?: string;
        steps?: number;
        guidanceScale?: number;
        seed?: number;
        negativePrompt?: string;
        count?: number;
      };
    };
  }
) {
  const { messageId, ...imageGenerationData } = args;

  // Use withRetry to handle write conflicts - re-reads message on each retry
  const message = await withRetry(async () => {
    // Get current message to preserve existing imageGeneration data
    const message = await ctx.db.get("messages", messageId);
    if (!message) {
      return null;
    }

    // Merge with existing imageGeneration data
    const currentImageGeneration = message.imageGeneration || {};
    const filteredImageGenerationData = Object.fromEntries(
      Object.entries(imageGenerationData).filter(
        ([_, value]) => value !== undefined
      )
    );

    // Deep merge metadata to preserve nested fields like params.aspectRatio
    const mergedMetadata =
      filteredImageGenerationData.metadata && currentImageGeneration.metadata
        ? {
            ...(typeof currentImageGeneration.metadata === "object" &&
            currentImageGeneration.metadata !== null &&
            !Array.isArray(currentImageGeneration.metadata)
              ? currentImageGeneration.metadata
              : {}),
            ...(typeof filteredImageGenerationData.metadata === "object" &&
            filteredImageGenerationData.metadata !== null &&
            !Array.isArray(filteredImageGenerationData.metadata)
              ? filteredImageGenerationData.metadata
              : {}),
            params: {
              ...(typeof currentImageGeneration.metadata === "object" &&
              currentImageGeneration.metadata !== null &&
              !Array.isArray(currentImageGeneration.metadata) &&
              currentImageGeneration.metadata.params
                ? currentImageGeneration.metadata.params
                : {}),
              ...(typeof filteredImageGenerationData.metadata === "object" &&
              filteredImageGenerationData.metadata !== null &&
              !Array.isArray(filteredImageGenerationData.metadata) &&
              filteredImageGenerationData.metadata.params
                ? filteredImageGenerationData.metadata.params
                : {}),
            },
          }
        : filteredImageGenerationData.metadata ||
          currentImageGeneration.metadata;

    const updatedImageGeneration = {
      ...currentImageGeneration,
      ...filteredImageGenerationData,
      ...(mergedMetadata &&
      typeof mergedMetadata === "object" &&
      !Array.isArray(mergedMetadata)
        ? { metadata: mergedMetadata }
        : {}),
    };

    // Update the message with new imageGeneration data
    const updateData: {
      imageGeneration: typeof updatedImageGeneration;
      status?: "done" | "error" | "streaming";
      metadata?: Record<string, unknown>;
    } = {
      imageGeneration: updatedImageGeneration,
    };

    // Update message status based on image generation status
    if (args.status === "succeeded") {
      updateData.status = "done";
      // Also update metadata to mark streaming as complete
      updateData.metadata = {
        ...message.metadata,
        finishReason: "stop",
      };
    } else if (args.status === "failed" || args.status === "canceled") {
      updateData.status = "error";
      // Also update metadata to mark streaming as complete
      updateData.metadata = {
        ...message.metadata,
        finishReason: "error",
      };
    } else if (args.status === "starting" || args.status === "processing") {
      // For retry: set message status back to streaming and clear previous finish state
      updateData.status = "streaming";
      // Clear any previous finishReason to allow isStreaming to return true
      updateData.metadata = {
        ...message.metadata,
        finishReason: undefined,
        stopped: undefined,
      };
    }

    await ctx.db.patch("messages", messageId, updateData);
    return message;
  });

  if (!message) {
    return;
  }

  // Handle conversation update separately with its own retry
  const terminalStatuses = new Set(["succeeded", "failed", "canceled"]);
  if (
    args.status &&
    terminalStatuses.has(args.status) &&
    message.conversationId
  ) {
    await withRetry(async () => {
      await ctx.db.patch("conversations", message.conversationId, {
        isStreaming: false,
        activeImageGeneration: undefined, // Clear tracking for OCC-free stop detection
      });
    }).catch(error => {
      console.warn(
        "[updateImageGeneration] Failed to clear conversation streaming state",
        {
          conversationId: message.conversationId,
          status: args.status,
          error: error instanceof Error ? error.message : String(error),
        }
      );
    });
  }
}

export async function getByReplicateIdHandler(
  ctx: QueryCtx,
  args: { replicateId: string }
) {
  // Use index for efficient lookup instead of full table scan
  return await ctx.db
    .query("messages")
    .withIndex("by_replicate_id", q =>
      q.eq("imageGeneration.replicateId", args.replicateId)
    )
    .first();
}

export async function setTtsAudioCacheHandler(
  ctx: MutationCtx,
  args: {
    messageId: Id<"messages">;
    entries?: Infer<typeof ttsAudioCacheEntrySchema>[];
  }
) {
  await ctx.db.patch("messages", args.messageId, {
    ttsAudioCache: args.entries ?? undefined,
  });
}
